<!--
This is a polyfill for CSS Behavior, like IEs a HTML Component aka HTC. It
allows you to attach JavaScript behavior to elements via CSS.

Example usage:
In your CSS, you can write:

```css
.my-element {
  --behavior: url('path/to/your-behavior.js');
}
```

And in your JavaScript file ("your-behavior.js"), you can define the behavior:

```js
export default function(element) {
  element.addEventListener('click', () => {
    alert('Element clicked!');
  });
}
```
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>CSS Behavior (like IE-HTC)</title>
</head>
<style>
  .background-red {
    --behavior: url('./css-behavior/behaviors/test.mjs');
  }
</style>
<body>
<div class="background-red" data-has-behavior>This is a test behavior (./css-behavior/behaviors/test.mjs)!</div>
<div class="background-red" data-has-behavior>This is a test behavior (2) (./css-behavior/behaviors/test.mjs)!</div>
<script>
  /*
  ### Element selection

  You should of course not scan the entire DOM for every element to check
  whether it has a `--behavior` property. That would be inefficient and slow.
  Therefore there should be a way to preselect elements. This can be done, for
  example, via a CSS class or an attribute.

  1. CSS class:
     ```css
     .has-behavior.your-behavior {
       --behavior: url('path/to/your-behavior.js');
     }
     ```
     ```html
        <div class="has-behavior"></div>
     ```
  2. Attribute:
     ```html
       <div style="--behavior: url(path/to/your-behavior.js);"></div>
     ```
     ```html
       <div data-has-behavior></div>
     ```
     ```html
       <div data-behavior="path/to/your-behavior.js"></div>
     ```
  */

  (function () {
    const behaviorProperty = '--behavior';
    const behaviorMap = new Map();

    function applyBehavior(element, url) {
      const existingBehavior = behaviorMap.get(url);

      if (existingBehavior) {
        if (existingBehavior instanceof Promise) {
          existingBehavior.then(behavior => behavior(element));
          return;
        }

        existingBehavior(element);
      }
      else {
        const promise = import(url)
          .then(module => {
            const behavior = module.default;
            behavior(element);
            behaviorMap.set(url, behavior);
            return behavior;
          }).catch(err => {
            console.error(`Failed to load behavior from ${url}:`, err);
          });

        behaviorMap.set(url, promise);
      }
    }

    function processElement(element) {
      const style = getComputedStyle(element);
      const behaviorUrl = style.getPropertyValue(behaviorProperty).trim();

      if (behaviorUrl) {
        const urlMatch = behaviorUrl.match(/url\(['"]?(.*?)['"]?\)/);
        if (urlMatch && urlMatch[1]) {
          applyBehavior(element, urlMatch[1]);
        }
      }
    }

    function observeMutations() {
      const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              processElement(node);
              node.querySelectorAll('*').forEach(child => processElement(child));
            }
          });
        });
      });

      observer.observe(document.documentElement, { childList: true, subtree: true });
    }

    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('*').forEach(element => processElement(element));
      observeMutations();
    });
  })();
</script>
</body>
</html>
